From aecfd0930d2faedd6933cf10b7853000854b9cbe Mon Sep 17 00:00:00 2001
From: Dhruv Gadhavi <dg28gadhavi@gmail.com>
Date: Tue, 11 Jul 2017 17:08:25 +0530
Subject: [PATCH] MTK patches-CORE

---
 healthd/Android.mk                |  50 +++---
 healthd/BatteryMonitor.cpp        | 136 +++++++---------
 healthd/healthd.cpp               |  37 ++---
 healthd/healthd_board_default.cpp |   2 +-
 healthd/include/healthd/healthd.h |   4 +-
 include/netutils/ifc.h            |  14 ++
 init/init.cpp                     |   2 +-
 init/init.h                       |   2 +-
 init/property_service.cpp         | 112 ++-----------
 init/property_service.h           |   2 -
 init/service.cpp                  |   9 +-
 libcutils/Android.mk              |   5 +-
 libcutils/fs_config.c             |   2 +-
 libcutils/mtk_audioCompat.c       |   4 +
 libcutils/mtk_xlog.cpp            |  27 ++++
 libnetutils/ifc_utils.c           | 323 ++++++++++++++++++++++++++++++++++++++
 16 files changed, 481 insertions(+), 250 deletions(-)
 create mode 100644 libcutils/mtk_audioCompat.c
 create mode 100644 libcutils/mtk_xlog.cpp

diff --git a/healthd/Android.mk b/healthd/Android.mk
index e0fb0cc7b..4804887c8 100644
--- a/healthd/Android.mk
+++ b/healthd/Android.mk
@@ -37,31 +37,6 @@ LOCAL_SRC_FILES := \
     AnimationParser.cpp \
     BatteryPropertiesRegistrar.cpp \
 
-HEALTHD_CHARGER_DEFINES := RED_LED_PATH \
-    GREEN_LED_PATH \
-    BLUE_LED_PATH \
-    BLINK_PATH \
-    BACKLIGHT_PATH \
-    CHARGING_ENABLED_PATH
-
-$(foreach healthd_charger_define,$(HEALTHD_CHARGER_DEFINES), \
-  $(if $($(healthd_charger_define)), \
-    $(eval LOCAL_CFLAGS += -D$(healthd_charger_define)=\"$($(healthd_charger_define))\") \
-  ) \
-)
-
-ifeq ($(strip $(BOARD_CHARGER_DISABLE_INIT_BLANK)),true)
-LOCAL_CFLAGS += -DCHARGER_DISABLE_INIT_BLANK
-endif
-
-ifeq ($(strip $(BOARD_CHARGER_ENABLE_SUSPEND)),true)
-LOCAL_CFLAGS += -DCHARGER_ENABLE_SUSPEND
-endif
-
-ifeq ($(strip $(BOARD_NO_CHARGER_LED)),true)
-LOCAL_CFLAGS += -DNO_CHARGER_LED
-endif
-
 LOCAL_MODULE := libhealthd_internal
 LOCAL_C_INCLUDES := $(call project-path-for,recovery)
 LOCAL_EXPORT_C_INCLUDE_DIRS := \
@@ -97,6 +72,31 @@ LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_SBIN_UNSTRIPPED)
 
 LOCAL_CFLAGS := -D__STDC_LIMIT_MACROS -Werror
 
+HEALTHD_CHARGER_DEFINES := RED_LED_PATH \
+    GREEN_LED_PATH \
+    BLUE_LED_PATH \
+    BLINK_PATH \
+    BACKLIGHT_PATH \
+    CHARGING_ENABLED_PATH
+
+$(foreach healthd_charger_define,$(HEALTHD_CHARGER_DEFINES), \
+  $(if $($(healthd_charger_define)), \
+    $(eval LOCAL_CFLAGS += -D$(healthd_charger_define)=\"$($(healthd_charger_define))\") \
+  ) \
+)
+
+ifeq ($(strip $(BOARD_CHARGER_DISABLE_INIT_BLANK)),true)
+LOCAL_CFLAGS += -DCHARGER_DISABLE_INIT_BLANK
+endif
+
+ifeq ($(strip $(BOARD_CHARGER_ENABLE_SUSPEND)),true)
+LOCAL_CFLAGS += -DCHARGER_ENABLE_SUSPEND
+endif
+
+ifeq ($(strip $(BOARD_NO_CHARGER_LED)),true)
+LOCAL_CFLAGS += -DNO_CHARGER_LED
+endif
+
 ifneq ($(BOARD_PERIODIC_CHORES_INTERVAL_FAST),)
 LOCAL_CFLAGS += -DBOARD_PERIODIC_CHORES_INTERVAL_FAST=$(BOARD_PERIODIC_CHORES_INTERVAL_FAST)
 endif
diff --git a/healthd/BatteryMonitor.cpp b/healthd/BatteryMonitor.cpp
index ee46f8315..e7b9de075 100644
--- a/healthd/BatteryMonitor.cpp
+++ b/healthd/BatteryMonitor.cpp
@@ -37,10 +37,6 @@
 
 #define POWER_SUPPLY_SUBSYSTEM "power_supply"
 #define POWER_SUPPLY_SYSFS_PATH "/sys/class/" POWER_SUPPLY_SUBSYSTEM
-#ifdef BATTERY_REAL_INFO
-#define SYSFS_BATTERY_CURRENT "/sys/class/power_supply/battery/current_now"
-#define SYSFS_BATTERY_VOLTAGE "/sys/class/power_supply/battery/voltage_now"
-#endif
 #define FAKE_BATTERY_CAPACITY 42
 #define FAKE_BATTERY_TEMPERATURE 424
 #define ALWAYS_PLUGGED_CAPACITY 100
@@ -168,19 +164,18 @@ BatteryMonitor::PowerSupplyType BatteryMonitor::readPowerSupplyType(const String
             { "Mains", ANDROID_POWER_SUPPLY_TYPE_AC },
             { "USB", ANDROID_POWER_SUPPLY_TYPE_USB },
             { "USB_DCP", ANDROID_POWER_SUPPLY_TYPE_AC },
-            { "USB_HVDCP", ANDROID_POWER_SUPPLY_TYPE_AC },
             { "USB_CDP", ANDROID_POWER_SUPPLY_TYPE_AC },
             { "USB_ACA", ANDROID_POWER_SUPPLY_TYPE_AC },
+            { "USB_HVDCP", ANDROID_POWER_SUPPLY_TYPE_AC },
+            { "USB_HVDCP_3", ANDROID_POWER_SUPPLY_TYPE_AC },
             { "USB_C", ANDROID_POWER_SUPPLY_TYPE_AC },
             { "USB_PD", ANDROID_POWER_SUPPLY_TYPE_AC },
             { "USB_PD_DRP", ANDROID_POWER_SUPPLY_TYPE_USB },
-            { "USB_HVDCP", ANDROID_POWER_SUPPLY_TYPE_AC },
-            { "USB_HVDCP_3", ANDROID_POWER_SUPPLY_TYPE_AC },
             { "Wireless", ANDROID_POWER_SUPPLY_TYPE_WIRELESS },
             { "Wipower", ANDROID_POWER_SUPPLY_TYPE_WIRELESS },
-            { "DASH", ANDROID_POWER_SUPPLY_TYPE_AC },
             { "DockBattery", ANDROID_POWER_SUPPLY_TYPE_DOCK_BATTERY },
             { "DockAC", ANDROID_POWER_SUPPLY_TYPE_DOCK_AC },
+            { "DASH", ANDROID_POWER_SUPPLY_TYPE_AC },
             { NULL, 0 },
     };
 
@@ -188,8 +183,10 @@ BatteryMonitor::PowerSupplyType BatteryMonitor::readPowerSupplyType(const String
         return ANDROID_POWER_SUPPLY_TYPE_UNKNOWN;
 
     ret = (BatteryMonitor::PowerSupplyType)mapSysfsString(buf, supplyTypeMap);
-    if (ret < 0)
+    if (ret < 0) {
+        KLOG_WARNING(LOG_TAG, "Unknown power supply type '%s'\n", buf);
         ret = ANDROID_POWER_SUPPLY_TYPE_UNKNOWN;
+    }
 
     return ret;
 }
@@ -221,7 +218,7 @@ int BatteryMonitor::getIntField(const String8& path) {
 
 bool BatteryMonitor::update(void) {
     bool logthis;
-
+    double MaxPower = 0;
     initBatteryProperties(&props);
 
     if (!mHealthdConfig->batteryPresentPath.isEmpty())
@@ -236,7 +233,24 @@ bool BatteryMonitor::update(void) {
 
     if (!mHealthdConfig->batteryCurrentNowPath.isEmpty())
         props.batteryCurrent = getIntField(mHealthdConfig->batteryCurrentNowPath) / 1000;
-
+    
+    if ((!mHealthdConfig->batteryCurrentMaxPath.isEmpty()) && (!mHealthdConfig->batteryVoltageMaxPath.isEmpty())) {
+       int ChargingCurrent = getIntField(mHealthdConfig->batteryCurrentMaxPath);
+       int ChargingVoltage = getIntField(mHealthdConfig->batteryVoltageMaxPath);
+       double power = ((double)ChargingCurrent / MILLION) * ((double)ChargingVoltage / MILLION);
+        if (MaxPower < power) {
+            props.maxChargingCurrent = ChargingCurrent;
+            props.maxChargingVoltage = ChargingVoltage;
+            MaxPower = power;
+        } else {
+	    props.maxChargingCurrent = 0;
+            props.maxChargingVoltage = DEFAULT_VBUS_VOLTAGE; 
+	} 
+    } else {
+       props.maxChargingCurrent = 0;
+       props.maxChargingVoltage = DEFAULT_VBUS_VOLTAGE;      
+    }
+   
     if (!mHealthdConfig->batteryFullChargePath.isEmpty())
         props.batteryFullCharge = getIntField(mHealthdConfig->batteryFullChargePath);
 
@@ -299,40 +313,17 @@ bool BatteryMonitor::update(void) {
     }
 
     unsigned int i;
-    double MaxPower = 0;
 
-    // reinitialize the mChargerNames vector everytime there is an update
+    for (i = 0; i < mChargerNames.size(); i++) {
     String8 path;
-    DIR* dir = opendir(POWER_SUPPLY_SYSFS_PATH);
-    if (dir == NULL) {
-        KLOG_ERROR(LOG_TAG, "Could not open %s\n", POWER_SUPPLY_SYSFS_PATH);
-    } else {
-        struct dirent* entry;
-        // reconstruct the charger strings
-        mChargerNames.clear();
-        while ((entry = readdir(dir))) {
-            const char* name = entry->d_name;
-
-            if (!strcmp(name, ".") || !strcmp(name, ".."))
-                continue;
+        path.appendFormat("%s/%s/online", POWER_SUPPLY_SYSFS_PATH,
+                          mChargerNames[i].string());
 
-            // Look for "type" file in each subdirectory
-            path.clear();
-            path.appendFormat("%s/%s/type", POWER_SUPPLY_SYSFS_PATH, name);
-            switch(readPowerSupplyType(path)) {
-            case ANDROID_POWER_SUPPLY_TYPE_BATTERY:
-            case ANDROID_POWER_SUPPLY_TYPE_DOCK_BATTERY:
-                break;
-            default:
-                path.clear();
-                path.appendFormat("%s/%s/online", POWER_SUPPLY_SYSFS_PATH, name);
-                if (access(path.string(), R_OK) == 0) {
-                    mChargerNames.add(String8(name));
                     if (readFromFile(path, buf, SIZE) > 0) {
                         if (buf[0] != '0') {
                             path.clear();
                             path.appendFormat("%s/%s/type", POWER_SUPPLY_SYSFS_PATH,
-                                              name);
+                                  mChargerNames[i].string());
                             switch(readPowerSupplyType(path)) {
                             case ANDROID_POWER_SUPPLY_TYPE_AC:
                                 props.chargerAcOnline = true;
@@ -349,52 +340,14 @@ bool BatteryMonitor::update(void) {
                                 }
                             default:
                                 KLOG_WARNING(LOG_TAG, "%s: Unknown power supply type\n",
-                                             name);
+                                 mChargerNames[i].string());
                             }
 
-#ifdef BATTERY_REAL_INFO
-                int ChargingCurrent =
-                      (access(SYSFS_BATTERY_CURRENT, R_OK) == 0) ? abs(getIntField(String8(SYSFS_BATTERY_CURRENT))) : 0;
-
-                int ChargingVoltage =
-                      (access(SYSFS_BATTERY_VOLTAGE, R_OK) == 0) ? getIntField(String8(SYSFS_BATTERY_VOLTAGE)) :
-                       DEFAULT_VBUS_VOLTAGE;
-#else
-
-                            //If its online, read the voltage and current for power
-                            path.clear();
-                            path.appendFormat("%s/%s/current_max", POWER_SUPPLY_SYSFS_PATH,
-                                            name);
-                            int ChargingCurrent =
-                                          (access(path.string(), R_OK) == 0) ? getIntField(path) : 0;
-
-                            path.clear();
-                            path.appendFormat("%s/%s/voltage_max", POWER_SUPPLY_SYSFS_PATH,
-                                            name);
-
-                            int ChargingVoltage =
-                              (access(path.string(), R_OK) == 0) ? getIntField(path) :
-                              DEFAULT_VBUS_VOLTAGE;
-
-#endif
-
-                            double power = ((double)ChargingCurrent / MILLION) *
-                                    ((double)ChargingVoltage / MILLION);
-                            if (MaxPower < power) {
-                                props.maxChargingCurrent = ChargingCurrent;
-                                props.maxChargingVoltage = ChargingVoltage;
-                                MaxPower = power;
-                            }
                         }
                     }
                 }
-                break;
-            } //switch
-        } //while
-        closedir(dir);
-    }//else
 
-    logthis = !healthd_board_battery_update(&props);
+    logthis = true; //!healthd_board_battery_update(&props);
 
     if (logthis) {
         char dmesgline[256];
@@ -403,12 +356,12 @@ bool BatteryMonitor::update(void) {
 
         if (props.batteryPresent) {
             snprintf(dmesgline, sizeof(dmesgline),
-                 "battery [l=%d v=%d t=%s%d.%d h=%d st=%d]",
+                 "battery [Level=%d Voltage=%d Temp=%s%d.%d Health=%d Status=%d ChgCurrent=%d ChgVoltage=%d]",
                  props.batteryLevel, props.batteryVoltage,
                  props.batteryTemperature < 0 ? "-" : "",
                  abs(props.batteryTemperature / 10),
                  abs(props.batteryTemperature % 10), props.batteryHealth,
-                 props.batteryStatus);
+                 props.batteryStatus, props.maxChargingCurrent/1000 <= 0 ? 0 : props.maxChargingCurrent/1000, props.maxChargingVoltage/1000 <= 0 ? 0 : props.maxChargingVoltage/1000);
 
             len = strlen(dmesgline);
             if (!mHealthdConfig->batteryCurrentNowPath.isEmpty()) {
@@ -465,7 +418,6 @@ bool BatteryMonitor::update(void) {
                      props.chargerWirelessOnline ? "w" : "",
                      props.chargerDockAcOnline ? "d" : "");
     }
-
     healthd_mode_ops->battery_update(&props);
     return props.chargerAcOnline | props.chargerUsbOnline |
             props.chargerWirelessOnline | props.chargerDockAcOnline;
@@ -774,7 +726,23 @@ void BatteryMonitor::init(struct healthd_config *hc) {
                     if (access(path, R_OK) == 0)
                         mHealthdConfig->batteryFullChargePath = path;
                 }
-
+                
+                if (mHealthdConfig->batteryCurrentMaxPath.isEmpty()) {
+                    path.clear();
+                    path.appendFormat("%s/%s/current_max",
+                                      POWER_SUPPLY_SYSFS_PATH, name);
+                    if (access(path, R_OK) == 0)
+                        mHealthdConfig->batteryCurrentMaxPath = path;
+                }
+                
+                if (mHealthdConfig->batteryVoltageMaxPath.isEmpty()) {
+                    path.clear();
+                    path.appendFormat("%s/%s/voltage_max",
+                                      POWER_SUPPLY_SYSFS_PATH, name);
+                    if (access(path, R_OK) == 0)
+                        mHealthdConfig->batteryVoltageMaxPath = path;
+                }
+                
                 if (mHealthdConfig->batteryCurrentNowPath.isEmpty()) {
                     path.clear();
                     path.appendFormat("%s/%s/current_now",
@@ -966,6 +934,10 @@ void BatteryMonitor::init(struct healthd_config *hc) {
             KLOG_WARNING(LOG_TAG, "BatteryTechnologyPath not found\n");
         if (mHealthdConfig->batteryCurrentNowPath.isEmpty())
             KLOG_WARNING(LOG_TAG, "BatteryCurrentNowPath not found\n");
+        if (mHealthdConfig->batteryCurrentMaxPath.isEmpty())
+            KLOG_WARNING(LOG_TAG, "batteryCurrentMaxPath not found\n");
+        if (mHealthdConfig->batteryVoltageMaxPath.isEmpty())
+            KLOG_WARNING(LOG_TAG, "batteryVoltageMaxPath not found\n");	
         if (mHealthdConfig->batteryFullChargePath.isEmpty())
             KLOG_WARNING(LOG_TAG, "BatteryFullChargePath not found\n");
         if (mHealthdConfig->batteryCycleCountPath.isEmpty())
diff --git a/healthd/healthd.cpp b/healthd/healthd.cpp
index 45d96c9ea..c6a34bb11 100644
--- a/healthd/healthd.cpp
+++ b/healthd/healthd.cpp
@@ -37,25 +37,8 @@
 using namespace android;
 
 // Periodic chores intervals in seconds
-#ifndef BOARD_PERIODIC_CHORES_INTERVAL_FAST
- #ifdef QCOM_HARDWARE
-  #define DEFAULT_PERIODIC_CHORES_INTERVAL_FAST (60 * 10)
- #else
-  #define DEFAULT_PERIODIC_CHORES_INTERVAL_FAST (60 * 1)
- #endif
-#else
-  #define DEFAULT_PERIODIC_CHORES_INTERVAL_FAST (BOARD_PERIODIC_CHORES_INTERVAL_FAST)
-#endif
-
-#ifndef BOARD_PERIODIC_CHORES_INTERVAL_SLOW
- #ifdef QCOM_HARDWARE
-  #define DEFAULT_PERIODIC_CHORES_INTERVAL_SLOW -1
- #else
-  #define DEFAULT_PERIODIC_CHORES_INTERVAL_SLOW (60 * 10)
- #endif
-#else
-  #define DEFAULT_PERIODIC_CHORES_INTERVAL_SLOW (BOARD_PERIODIC_CHORES_INTERVAL_SLOW)
-#endif
+#define DEFAULT_PERIODIC_CHORES_INTERVAL_FAST (24 * 60 * 60)
+#define DEFAULT_PERIODIC_CHORES_INTERVAL_SLOW (24 * 60 * 60)
 
 static struct healthd_config healthd_config = {
     .periodic_chores_interval_fast = DEFAULT_PERIODIC_CHORES_INTERVAL_FAST,
@@ -72,6 +55,8 @@ static struct healthd_config healthd_config = {
     .batteryChargeCounterPath = String8(String8::kEmptyString),
     .batteryFullChargePath = String8(String8::kEmptyString),
     .batteryCycleCountPath = String8(String8::kEmptyString),
+    .batteryCurrentMaxPath = String8(String8::kEmptyString),
+    .batteryVoltageMaxPath = String8(String8::kEmptyString),
     .energyCounter = NULL,
     .boot_min_cap = 0,
     .screen_on = NULL,
@@ -314,17 +299,12 @@ static void wakealarm_init(void) {
 }
 
 static void healthd_mainloop(void) {
-    int nevents = 0;
     while (1) {
         struct epoll_event events[eventct];
+        int nevents;
         int timeout = awake_poll_interval;
         int mode_timeout;
 
-        /* Don't wait for first timer timeout to run periodic chores */
-        if (!nevents)
-            periodic_chores();
-
-        healthd_mode_ops->heartbeat();
 
         mode_timeout = healthd_mode_ops->preparetowait();
         if (timeout < 0 || (mode_timeout > 0 && mode_timeout < timeout))
@@ -341,6 +321,10 @@ static void healthd_mainloop(void) {
             if (events[n].data.ptr)
                 (*(void (*)(int))events[n].data.ptr)(events[n].events);
         }
+        if (!nevents)
+            periodic_chores();
+
+        healthd_mode_ops->heartbeat();
     }
 
     return;
@@ -397,9 +381,6 @@ int main(int argc, char **argv) {
         exit(2);
     }
 
-    periodic_chores();
-    healthd_mode_ops->heartbeat();
-
     healthd_mainloop();
     KLOG_ERROR("Main loop terminated, exiting\n");
     return 3;
diff --git a/healthd/healthd_board_default.cpp b/healthd/healthd_board_default.cpp
index fdb970bb6..960f0d21b 100644
--- a/healthd/healthd_board_default.cpp
+++ b/healthd/healthd_board_default.cpp
@@ -25,7 +25,7 @@ void healthd_board_init(struct healthd_config*)
 int healthd_board_battery_update(struct android::BatteryProperties*)
 {
     // return 0 to log periodic polled battery status to kernel log
-    return 1;
+    return 0;
 }
 
 void healthd_board_mode_charger_draw_battery(struct android::BatteryProperties*)
diff --git a/healthd/include/healthd/healthd.h b/healthd/include/healthd/healthd.h
index e9f9da31d..58c3d4117 100644
--- a/healthd/include/healthd/healthd.h
+++ b/healthd/include/healthd/healthd.h
@@ -85,7 +85,9 @@ struct healthd_config {
     android::String8 batteryChargeCounterPath;
     android::String8 batteryFullChargePath;
     android::String8 batteryCycleCountPath;
-
+    android::String8 batteryCurrentMaxPath;
+    android::String8 batteryVoltageMaxPath;
+    
     int (*energyCounter)(int64_t *);
     int boot_min_cap;
     bool (*screen_on)(android::BatteryProperties *props);
diff --git a/include/netutils/ifc.h b/include/netutils/ifc.h
index 3b272343d..408f6180a 100644
--- a/include/netutils/ifc.h
+++ b/include/netutils/ifc.h
@@ -61,6 +61,20 @@ extern int ifc_configure(const char *ifname, in_addr_t address,
 
 extern in_addr_t prefixLengthToIpv4Netmask(int prefix_length);
 
+#ifdef MTK_HARDWARE
+extern int ifc_is_up(const char *name, unsigned *isup);
+extern int ifc_enable_allmc(const char *name);
+extern int ifc_disable_allmc(const char *name);
+extern int ifc_reset_connection_by_uid(int uid, int error); 
+extern int ifc_set_throttle(const char *ifname, int rxKbps, int txKbps);
+extern int ifc_set_fwmark_rule(const char *ifname, int mark, int add);
+extern int ifc_set_txq_state(const char *ifname, int state);
+extern int ifc_ccmni_md_cfg(const char *ifname, int md_id);
+struct uid_err {
+    int appuid;
+	int errorNum;
+};
+#endif
 __END_DECLS
 
 #endif /* _NETUTILS_IFC_H_ */
diff --git a/init/init.cpp b/init/init.cpp
index 7a370596e..f0b0d4f0f 100755
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -85,7 +85,7 @@ int have_console;
 std::string console_name = "/dev/console";
 static time_t process_needs_restart;
 
-const char *ENV[32];
+const char *ENV[64];
 
 bool waiting_for_exec = false;
 
diff --git a/init/init.h b/init/init.h
index 345d442c0..f93d0c5ba 100644
--- a/init/init.h
+++ b/init/init.h
@@ -24,7 +24,7 @@ class Service;
 
 #define COMMAND_RETRY_TIMEOUT 5
 
-extern const char *ENV[32];
+extern const char *ENV[64];
 extern bool waiting_for_exec;
 extern int have_console;
 extern std::string console_name;
diff --git a/init/property_service.cpp b/init/property_service.cpp
index fc147966b..8644329b2 100644
--- a/init/property_service.cpp
+++ b/init/property_service.cpp
@@ -27,7 +27,6 @@
 #include <sys/poll.h>
 
 #include <memory>
-#include <queue>
 
 #include <cutils/misc.h>
 #include <cutils/sockets.h>
@@ -202,6 +201,16 @@ static int property_set_impl(const char* name, const char* value) {
     if (!is_legal_property_name(name, namelen)) return -1;
     if (valuelen >= PROP_VALUE_MAX) return -1;
 
+    if (strcmp("selinux.reload_policy", name) == 0 && strcmp("1", value) == 0) {
+        if (selinux_reload_policy() != 0) {
+            ERROR("Failed to reload policy\n");
+        }
+    } else if (strcmp("selinux.restorecon_recursive", name) == 0 && valuelen > 0) {
+        if (restorecon_recursive(value) != 0) {
+            ERROR("Failed to restorecon_recursive %s\n", value);
+        }
+    }
+
     prop_info* pi = (prop_info*) __system_property_find(name);
 
     if(pi != 0) {
@@ -238,108 +247,7 @@ static int property_set_impl(const char* name, const char* value) {
     return 0;
 }
 
-typedef int (*property_async_func_t)(const char* name, const char* value);
-
-struct property_child_info {
-    pid_t                       pid;
-    property_async_func_t       func;
-    char*                       name;
-    char*                       value;
-};
-
-static std::queue<property_child_info> property_children;
-
-static void property_child_launch(void)
-{
-    auto& info = property_children.front();
-    pid_t pid = fork();
-    if (pid < 0) {
-        ERROR("Failed to fork property child process\n");
-        while (!property_children.empty()) {
-            info = property_children.front();
-            free(info.name);
-            free(info.value);
-            property_children.pop();
-        }
-        return;
-    }
-    if (pid != 0) {
-        info.pid = pid;
-    }
-    else {
-        if (info.func(info.name, info.value) != 0) {
-            ERROR("Failed to set async property %s\n", info.name);
-        }
-
-        exit(0);
-    }
-}
-
-bool property_child_reap(pid_t pid)
-{
-    if (property_children.empty()) {
-        return false;
-    }
-    auto& info = property_children.front();
-    if (info.pid != pid) {
-        return false;
-    }
-    int rc = property_set_impl(info.name, info.value);
-    if (rc != 0) {
-        ERROR("property_set(\"%s\", \"%s\") failed\n", info.name, info.value);
-    }
-    free(info.name);
-    free(info.value);
-    property_children.pop();
-    if (property_children.size() > 0) {
-        property_child_launch();
-    }
-    return true;
-}
-
-static bool property_set_async(const char* name,
-                               const char* value,
-                               property_async_func_t func)
-{
-    if (!*value) {
-        int rc = property_set_impl(name, value);
-        return (rc == 0);
-    }
-
-    property_child_info info;
-    memset(&info, 0, sizeof(info));
-    info.func = func;
-    info.name = strdup(name);
-    info.value = strdup(value);
-    property_children.push(info);
-    if (property_children.size() == 1) {
-        ERROR("property_set_async: launch child\n");
-        property_child_launch();
-    }
-    return true;
-}
-
-static int restorecon_recursive_async(const char* name, const char* value)
-{
-    return restorecon_recursive(value);
-}
-
 int property_set(const char* name, const char* value) {
-
-    // Handle magic properties
-    if (strcmp("selinux.reload_policy", name) == 0 && strcmp("1", value) == 0) {
-        if (selinux_reload_policy() != 0) {
-            ERROR("Failed to reload policy\n");
-        }
-    } else if (strcmp("selinux.restorecon_recursive", name) == 0 ||
-               strncmp("selinux.restorecon_recursive.", name,
-                       strlen("selinux.restorecon_recursive.")) == 0) {
-        if (!property_set_async(name, value, restorecon_recursive_async)) {
-            ERROR("property_set(\"%s\", \"%s\") failed\n", name, value);
-        }
-        return 0;
-    }
-
     int rc = property_set_impl(name, value);
     if (rc == -1) {
         ERROR("property_set(\"%s\", \"%s\") failed\n", name, value);
diff --git a/init/property_service.h b/init/property_service.h
index 8735eea9f..aa92fa515 100644
--- a/init/property_service.h
+++ b/init/property_service.h
@@ -27,8 +27,6 @@ struct property_audit_data {
     const char* name;
 };
 
-extern bool property_child_reap(pid_t pid);
-
 extern void property_init(void);
 extern void property_load_boot_defaults(void);
 extern void load_persist_props(void);
diff --git a/init/service.cpp b/init/service.cpp
index 8127e708d..85544e7d8 100644
--- a/init/service.cpp
+++ b/init/service.cpp
@@ -373,9 +373,10 @@ bool Service::Start() {
         }
         if (rc == 0 && scon == mycon) {
             ERROR("Service %s does not have a SELinux domain defined.\n", name_.c_str());
-            free(mycon);
-            free(fcon);
-            return false;
+			// zormax
+            //free(mycon);
+            //free(fcon);
+            //return false;
         }
         free(mycon);
         free(fcon);
@@ -780,8 +781,6 @@ bool ServiceManager::ReapOneProcess() {
     } else if (pid == -1) {
         ERROR("waitpid failed: %s\n", strerror(errno));
         return false;
-    } else if (property_child_reap(pid)) {
-        return true;
     }
 
     Service* svc = FindServiceByPid(pid);
diff --git a/libcutils/Android.mk b/libcutils/Android.mk
index 7a922539f..c080b2d2a 100644
--- a/libcutils/Android.mk
+++ b/libcutils/Android.mk
@@ -102,6 +102,8 @@ LOCAL_SRC_FILES := $(libcutils_common_sources) \
         qtaguid.c \
         trace-dev.c \
         uevent.c \
+        mtk_xlog.cpp \
+        mtk_audioCompat.c
 
 LOCAL_SRC_FILES_arm += arch-arm/memset32.S
 LOCAL_SRC_FILES_arm64 += arch-arm64/android_memset.S
@@ -133,7 +135,8 @@ endif
 ifneq ($(ENABLE_SCHEDBOOST),)
 LOCAL_CFLAGS += -DUSE_SCHEDBOOST
 endif
-LOCAL_CFLAGS += -Werror -Wall -Wextra -std=gnu90
+#LOCAL_CFLAGS += -Werror -Wall -Wextra -std=gnu90
+LOCAL_CFLAGS += -Wall -Wextra -std=gnu90
 LOCAL_CLANG := true
 LOCAL_SANITIZE := integer
 include $(BUILD_STATIC_LIBRARY)
diff --git a/libcutils/fs_config.c b/libcutils/fs_config.c
index 68cfcbe00..3c01c79f8 100644
--- a/libcutils/fs_config.c
+++ b/libcutils/fs_config.c
@@ -143,7 +143,7 @@ static const struct fs_path_config android_files[] = {
     { 00700, AID_SYSTEM,    AID_SHELL,     CAP_MASK_LONG(CAP_BLOCK_SUSPEND), "system/bin/inputflinger" },
 
     /* Support FIFO scheduling mode in SurfaceFlinger. */
-    { 00755, AID_SYSTEM,    AID_GRAPHICS,     CAP_MASK_LONG(CAP_SYS_NICE), "system/bin/surfaceflinger" },
+    //{ 00755, AID_SYSTEM,    AID_GRAPHICS,     CAP_MASK_LONG(CAP_SYS_NICE), "system/bin/surfaceflinger" },
 
     { 00750, AID_ROOT,      AID_ROOT,      0, "system/bin/uncrypt" },
     { 00750, AID_ROOT,      AID_ROOT,      0, "system/bin/install-recovery.sh" },
diff --git a/libcutils/mtk_audioCompat.c b/libcutils/mtk_audioCompat.c
new file mode 100644
index 000000000..7b00e646d
--- /dev/null
+++ b/libcutils/mtk_audioCompat.c
@@ -0,0 +1,4 @@
+int get_capture_position(void)
+{
+    return 0;
+}
diff --git a/libcutils/mtk_xlog.cpp b/libcutils/mtk_xlog.cpp
new file mode 100644
index 000000000..48abe313c
--- /dev/null
+++ b/libcutils/mtk_xlog.cpp
@@ -0,0 +1,27 @@
+#include <cutils/log.h>
+
+extern "C" {
+	struct xlog_record {
+		const char *tag_str;
+		const char *fmt_str;
+		int prio;
+	};
+
+	static void init(void) __attribute__ ((constructor));
+
+	void init(void){}
+
+	int __xlog_buf_printf(int bufid, const struct xlog_record *rec, ...)
+	{
+	  va_list args;
+	  va_start(args, rec);
+	  LOG_PRI_VA(rec->prio, rec->tag_str, rec->fmt_str, args);
+	  va_end(args);
+
+	  return 0;
+	}
+
+	void dl_unregister_notify_function(void){}
+
+	void dl_register_notify_function(int (*load_notify_function) (const char *name, uintptr_t address, uintptr_t size), int(*unload_notify_function) (const char *name, uintptr_t address)){}
+}
diff --git a/libnetutils/ifc_utils.c b/libnetutils/ifc_utils.c
index 7739cf459..a9ac60b85 100644
--- a/libnetutils/ifc_utils.c
+++ b/libnetutils/ifc_utils.c
@@ -37,6 +37,9 @@
 #include <linux/ipv6_route.h>
 #include <linux/rtnetlink.h>
 #include <linux/sockios.h>
+#ifdef MTK_HARDWARE
+#include <linux/un.h>
+#endif
 
 #include "netutils/ifc.h"
 
@@ -54,6 +57,9 @@
 #if defined(__ANDROID__)
 /* SIOCKILLADDR is an Android extension. */
 #define SIOCKILLADDR 0x8939
+#ifdef MTK_HARDWARE
+#define SIOCKILLSOCK 0x893a
+#endif
 #endif
 
 static int ifc_ctl_sock = -1;
@@ -737,3 +743,320 @@ ifc_configure(const char *ifname,
 
     return 0;
 }
+
+#ifdef MTK_HARDWARE
+int ifc_reset_connection_by_uid(int uid, int error)
+{
+#if defined(__ANDROID__)
+
+    int tcp_ctl_sock;
+    int result = -1;
+    struct uid_err uid_e;
+
+	uid_e.appuid = uid;
+	uid_e.errorNum = error;
+
+    tcp_ctl_sock = socket(AF_INET, SOCK_STREAM, 0);
+    if (tcp_ctl_sock < 0) {
+        printerr("socket() failed: %s\n", strerror(errno));
+        return -1;
+    }
+
+    if(uid_e.appuid < 0){
+        ALOGE("ifc_reset_connection_by_uid, invalide uid: %d", uid_e.appuid);
+        close(tcp_ctl_sock);
+        return -1;
+    }
+
+    ALOGD("ifc_reset_connection_by_uid, appuid = %d, error = %d ",
+		      uid_e.appuid, uid_e.errorNum);
+    result = ioctl(tcp_ctl_sock, SIOCKILLSOCK, &uid_e);
+    if(result < 0)
+        ALOGE("ifc_reset_connection_by_uid, result= %d, error =%s ", result, strerror(errno));
+
+        close(tcp_ctl_sock);
+    ALOGD("ifc_reset_connection_by_uid, result= %d ",result);
+    return result;
+#else
+    return 0;
+#endif
+}
+
+int ifc_enable_allmc(const char *ifname)
+{
+	int result;
+
+	ifc_init();
+	result = ifc_set_flags(ifname, IFF_ALLMULTI, 0);
+	ifc_close();
+
+	ALOGD("ifc_enable_allmc(%s) = %d", ifname, result);
+	return result;
+}
+
+int ifc_disable_allmc(const char *ifname)
+{
+	int result;
+
+	ifc_init();
+	result = ifc_set_flags(ifname, 0, IFF_ALLMULTI);
+	ifc_close();
+
+	ALOGD("ifc_disable_allmc(%s) = %d", ifname, result);
+	return result;
+}
+int ifc_is_up(const char *name, unsigned *isup)
+{
+    struct ifreq ifr;
+    ifc_init_ifr(name, &ifr);
+
+    if(ioctl(ifc_ctl_sock, SIOCGIFFLAGS, &ifr) < 0) {
+        printerr("ifc_is_up get flags error:%d(%s)", errno, strerror(errno));
+        return -1;
+    }
+    if(ifr.ifr_flags & IFF_UP)
+        *isup = 1;
+    else
+        *isup = 0;
+
+    return 0;
+}
+
+static int ifc_netd_sock_init(void)
+{
+    int ifc_netd_sock;
+    const int one = 1;
+    struct sockaddr_un netd_addr;
+    int res = 0;
+
+        ifc_netd_sock = socket(AF_UNIX, SOCK_STREAM, 0);
+        if (ifc_netd_sock < 0) {
+            printerr("ifc_netd_sock_init: create socket failed");
+            return -1;
+        }
+
+        res = setsockopt(ifc_netd_sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
+        if (res < 0) {
+           printerr("setsockopt failed\n");
+           close(ifc_netd_sock);
+           return -1;
+        }
+        memset(&netd_addr, 0, sizeof(netd_addr));
+        netd_addr.sun_family = AF_UNIX;
+        strlcpy(netd_addr.sun_path, "/dev/socket/netd",
+            sizeof(netd_addr.sun_path));
+        if (TEMP_FAILURE_RETRY(connect(ifc_netd_sock,
+                     (const struct sockaddr*) &netd_addr,
+                     sizeof(netd_addr))) != 0) {
+            printerr("ifc_netd_sock_init: connect to netd failed, fd=%d, err: %d(%s)",
+                ifc_netd_sock, errno, strerror(errno));
+            close(ifc_netd_sock);
+            return -1;
+        }
+
+    if (DBG) printerr("ifc_netd_sock_init fd=%d", ifc_netd_sock);
+    return ifc_netd_sock;
+}
+
+/*do not call this function in netd*/
+int ifc_set_throttle(const char *ifname, int rxKbps, int txKbps)
+{
+    FILE* fnetd = NULL;
+    int ret = -1;
+    int seq = 1;
+    char rcv_buf[24];
+	int nread = 0;
+	int netd_sock = 0;
+
+    ALOGD("enter ifc_set_throttle: ifname = %s, rx = %d kbs, tx = %d kbs", ifname, rxKbps, txKbps);
+
+    netd_sock = ifc_netd_sock_init();
+    if(netd_sock <= 0)
+        goto exit;
+
+    // Send the request.
+    fnetd = fdopen(netd_sock, "r+");
+	if(fnetd == NULL){
+		ALOGE("open netd socket failed, err:%d(%s)", errno, strerror(errno));
+		goto exit;
+	}
+    if (fprintf(fnetd, "%d interface setthrottle %s %d %d", seq, ifname, rxKbps, txKbps) < 0) {
+        goto exit;
+    }
+    // literal NULL byte at end, required by FrameworkListener
+    if (fputc(0, fnetd) == EOF ||
+        fflush(fnetd) != 0) {
+        goto exit;
+    }
+    ret = 0;
+
+	//Todo: read the whole response from netd
+	nread = fread(rcv_buf, 1, 20, fnetd);
+	rcv_buf[23] = 0;
+	ALOGD("response: %s", rcv_buf);
+exit:
+    if (fnetd != NULL) {
+        fclose(fnetd);
+    }
+    return ret;
+}
+
+/*do not call this function in netd*/
+int ifc_set_fwmark_rule(const char *ifname, int mark, int add)
+{
+    FILE* fnetd = NULL;
+    int ret = -1;
+    int seq = 2;
+    char rcv_buf[24];
+    int nread = 0;
+    const char* op;
+    int netd_sock = 0;
+
+    if (add) {
+        op = "add";
+    } else {
+        op = "remove";
+    }
+    ALOGD("enter ifc_set_fwmark_rule: ifname = %s, mark = %d, op = %s", ifname, mark, op);
+
+    netd_sock = ifc_netd_sock_init();
+    if(netd_sock <= 0)
+        goto exit;
+
+    // Send the request.
+    fnetd = fdopen(netd_sock, "r+");
+     if(fnetd == NULL){
+           ALOGE("open netd socket failed, err:%d(%s)", errno, strerror(errno));
+           goto exit;
+       }
+    if (fprintf(fnetd, "%d network fwmark %s %s %d", seq, op, ifname, mark) < 0) {
+        goto exit;
+    }
+    // literal NULL byte at end, required by FrameworkListener
+    if (fputc(0, fnetd) == EOF ||
+        fflush(fnetd) != 0) {
+        goto exit;
+    }
+    ret = 0;
+
+        //Todo: read the whole response from netd
+        nread = fread(rcv_buf, 1, 20, fnetd);
+        rcv_buf[23] = 0;
+        ALOGD("ifc_set_fwmark_rule response: %s", rcv_buf);
+exit:
+    if (fnetd != NULL) {
+        fclose(fnetd);
+    }
+    return ret;
+}
+
+/*do not call this function in netd
+  * 0  disable nsiot firewall
+  * 1  enable nsiot firewall
+  */
+int ifc_set_nsiot_firewall(int flag)
+{
+    FILE* fnetd = NULL;
+    int ret = -1;
+    int seq = 2;
+    char rcv_buf[24];
+    int nread = 0;
+    const char* op;
+    int netd_sock = 0;
+    if (flag) {
+        op = "set_nsiot_firewall";
+    } else {
+        op = "clear_nsiot_firewall";
+    }
+    ALOGD("enter ifc_set_nsiot_firewall: op = %s",op);
+
+    netd_sock = ifc_netd_sock_init();
+    if(netd_sock <= 0)
+        goto exit;
+
+    // Send the request.
+    fnetd = fdopen(netd_sock, "r+");
+      if(fnetd == NULL){
+          ALOGE("open netd socket failed, err:%d(%s)", errno, strerror(errno));
+          goto exit;
+    }
+    if (fprintf(fnetd, "%d firewall %s ", seq, op) < 0) {
+        goto exit;
+    }
+    // literal NULL byte at end, required by FrameworkListener
+    if (fputc(0, fnetd) == EOF ||
+        fflush(fnetd) != 0) {
+        goto exit;
+    }
+    ret = 0;
+
+       //Todo: read the whole response from netd
+        nread = fread(rcv_buf, 1, 20, fnetd);
+        rcv_buf[23] = 0;
+        ALOGD("ifc_set_nsiot_firewall response: %s", rcv_buf);
+exit:
+    if (fnetd != NULL) {
+        fclose(fnetd);
+    }
+
+    return ret;
+}
+
+#define SIOCSTXQSTATE (SIOCDEVPRIVATE + 0)  //start/stop ccmni tx queue
+#define SIOCSCCMNICFG (SIOCDEVPRIVATE + 1)  //configure ccmni/md remapping
+
+int ifc_set_txq_state(const char *ifname, int state)
+{
+    struct ifreq ifr;
+    int ret, ctl_sock;
+
+    memset(&ifr, 0, sizeof(struct ifreq));
+    strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+    ifr.ifr_name[IFNAMSIZ - 1] = 0;
+    ifr.ifr_ifru.ifru_ivalue = state;
+
+    ctl_sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(ctl_sock < 0){
+    ALOGE("create ctl socket failed\n");
+      return -1;
+    }
+    ret = ioctl(ctl_sock, SIOCSTXQSTATE, &ifr);
+    if(ret < 0)
+       ALOGE("ifc_set_txq_state failed, err:%d(%s)\n", errno, strerror(errno));
+    else
+       ALOGI("ifc_set_txq_state as %d, ret: %d\n", state, ret);
+
+    close(ctl_sock);
+
+    return ret;
+}
+
+int ifc_ccmni_md_cfg(const char *ifname, int md_id)
+{
+    struct ifreq ifr;
+    int ret = 0;
+    int ctl_sock = 0;
+
+    ifc_init_ifr(ifname, &ifr);
+    ifr.ifr_ifru.ifru_ivalue = md_id;
+
+    ctl_sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(ctl_sock < 0){
+        printerr("ifc_ccmni_md_cfg: create ctl socket failed\n");
+        return -1;
+    }
+
+    if(ioctl(ctl_sock, SIOCSCCMNICFG, &ifr) < 0) {
+        printerr("ifc_ccmni_md_configure(ifname=%s, md_id=%d) error:%d(%s)", \
+             ifname, md_id, errno, strerror(errno));
+       ret = -1;
+    } else {
+        printerr("ifc_ccmni_md_configure(ifname=%s, md_id=%d) OK", ifname, md_id);
+    }
+
+    close(ctl_sock);
+    return ret;
+}
+
+
+#endif
\ No newline at end of file